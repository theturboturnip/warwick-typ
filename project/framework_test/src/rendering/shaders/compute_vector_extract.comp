#version 450
#extension GL_ARB_separate_shader_objects : enable

#include "global_descriptor_sets.glsl"
#include "global_structures.glsl"

layout (local_size_x = 16, local_size_y = 16) in;

SPEC_CONST_VECTOR_QUANTITY()

PUSH_CONSTANTS(VectorExtractParams)

// Declare the descriptor sets
DS_IMAGE_INPUT(0, rgba32f, simDataImage)
DS_IMAGE_OUTPUT(1, rgba32f, vectorResult) // Would use rgb32 if I could (excluding the alpha component) but that isn't a valid layout.
layout(set=2, binding=0, std430) writeonly buffer FloatRangeOutputs {
    FloatRange outputRanges[];
};

void main() {
    ivec2 pxIdx = ivec2(gl_GlobalInvocationID.xy);

    // Make sure we don't read out of bounds.
    if (pxIdx.x > pConsts.simDataImage_width || pxIdx.y > pConsts.simDataImage_height)
        return;

    vec4 data = imageLoad(simDataImage, pxIdx);

    switch(vectorQuantity) {
        case VectorQuantity_Velocity: {
            float magnitude = length(data.xy);
            imageStore(vectorResult, pxIdx, vec4(data.x, data.y, data.w, 0));
            // Put the quantity in as both min and max
            outputRanges[pxIdx.x * pConsts.simDataImage_height + pxIdx.y] = FloatRange(magnitude, magnitude);
            break;
        }
        case VectorQuantity_VelocityX:
            imageStore(vectorResult, pxIdx, vec4(data.x, 0, data.w, 0));
            // Put the quantity in as both min and max
            outputRanges[pxIdx.x * pConsts.simDataImage_height + pxIdx.y] = FloatRange(data.x, data.x);
            break;
        case VectorQuantity_VelocityY:
            imageStore(vectorResult, pxIdx, vec4(0, data.y, data.w, 0));
            // Put the quantity in as both min and max
            outputRanges[pxIdx.x * pConsts.simDataImage_height + pxIdx.y] = FloatRange(data.y, data.y);
            break;
        case VectorQuantity_None:
        default:
            imageStore(vectorResult, pxIdx, vec4(0, 0, data.w, 0));
            // Put the quantity in as both min and max
            outputRanges[pxIdx.x * pConsts.simDataImage_height + pxIdx.y] = FloatRange(0, 0);
            break;
    }
}